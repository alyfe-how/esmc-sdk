#!/usr/bin/env node
/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ESMC SDK v5.0 Â© 2025 Abelitie Designs Malaysia
 * Build: 2026-01-22 | https://esmc-sdk.com
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * âš ï¸  PROPRIETARY SOFTWARE - Licensed, Not Sold
 *
 *    ESMC is a commercial AI-powered development framework.
 *    Unauthorized use, copying, or distribution is strictly
 *    prohibited and will be prosecuted to the fullest extent
 *    of applicable law.
 *
 *    If you obtained this without purchase or valid license:
 *    â†’ Report to: security@esmc-sdk.com
 *    â†’ Purchase at: https://esmc-sdk.com
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

/**
 * ESMC 4.1 - Epsilon ATHENA CLI Wrapper
 * Purpose: CLI interface for ATHENA vetting infrastructure (ESMC 3.68 error detection)
 * L002 Compliance: Activates existing PHC/AESD/IC/CSPM/UID code via BRAIN.md execution protocol
 *
 * Prevention Architecture: "Prevention better than cure"
 *   - Context accuracy (full mesh + REASON) â†’ Pattern familiarity â†’ Zero iteration
 *   - Redesign loop DISABLED per user directive (focus on first-attempt accuracy)
 *
 * ESMC 4.1 Learning Loop:
 *   - Error-to-Lesson: IC/UID thresholds â†’ Auto-create lesson in .esmc-lessons.json
 *   - AESD-to-Precedent: Working solutions â†’ Add to .l5-precedents.json
 *   - Closed learning loop: Detect â†’ Learn â†’ Prevent future errors
 *
 * Commands:
 *   vet [--silent]           - Execute proactive error detection (PHASE 0.7)
 *   review <proposal_json>   - Full proposal vetting with verdict + learning
 *
 * Note: Review command provides feedback but does NOT trigger ECHELON resubmission
 *       User's strategy: Get it right the FIRST time via comprehensive context
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// ============================================================================
// ESMC 4.1: AUTO-LESSON CREATION (Error-to-Lesson Pipeline)
// ============================================================================

/**
 * Auto-create lesson when IC/UID thresholds exceeded
 * Closes the learning loop: Error detected â†’ Lesson created â†’ Future prevention
 */
function createAutoLesson(data) {
  const lessonsPath = path.resolve(process.cwd(), '.claude/memory/.esmc-lessons.json');

  try {
    let lessons;
    if (fs.existsSync(lessonsPath)) {
      lessons = JSON.parse(fs.readFileSync(lessonsPath, 'utf-8'));
    } else {
      lessons = {
        version: '1.0.0',
        system: 'AEGIS + CUP',
        created: new Date().toISOString(),
        last_updated: new Date().toISOString(),
        lessons: [],
        max_entries: 25
      };
    }

    // Generate next lesson ID
    const existingIds = lessons.lessons.map(l => parseInt(l.id.replace('L', ''))).filter(n => !isNaN(n));
    const nextId = existingIds.length > 0 ? Math.max(...existingIds) + 1 : 3;
    const lessonId = `L${String(nextId).padStart(3, '0')}`;

    // Check if similar lesson already exists (prevent duplicates)
    const topicLower = (data.topic || '').toLowerCase();
    const exists = lessons.lessons.some(l =>
      l.trigger_keywords?.some(kw => topicLower.includes(kw.toLowerCase()))
    );

    if (exists) {
      return { created: false, reason: 'Similar lesson already exists' };
    }

    // Build lesson from error detection data
    const lesson = {
      id: lessonId,
      date: new Date().toISOString().split('T')[0],
      category: data.ic >= 3 ? 'iteration_pattern' : 'intervention_pattern',
      severity: data.ic >= 5 || data.uid >= 5 ? 'critical' : 'high',
      lesson: `Approach "${data.topic}" failed ${data.ic} times with ${data.uid} corrections - apply precedent solution instead`,
      context: `Auto-generated by ATHENA learning loop. IC=${data.ic}, UID=${data.uid}. ${data.aesd_solutions?.length || 0} precedent solutions available.`,
      trigger_keywords: extractTriggerKeywords(data.topic),
      components_affected: ['ECHELON', 'ATHENA', 'PIU', 'DKI'],
      frustration_score: Math.min(100, (data.ic * 15) + (data.uid * 20)),
      repetition_count: data.ic,
      auto_generated: true,
      precedent_solutions: data.aesd_solutions || []
    };

    lessons.lessons.push(lesson);
    lessons.last_updated = new Date().toISOString();

    // Enforce max_entries (FIFO rotation for non-critical)
    if (lessons.lessons.length > lessons.max_entries) {
      const nonCritical = lessons.lessons.filter(l => l.severity !== 'critical');
      if (nonCritical.length > 0) {
        const oldest = nonCritical[0];
        lessons.lessons = lessons.lessons.filter(l => l.id !== oldest.id);
      }
    }

    fs.writeFileSync(lessonsPath, JSON.stringify(lessons, null, 2));

    return { created: true, lesson_id: lessonId, lesson: lesson };
  } catch (error) {
    return { created: false, error: error.message };
  }
}

/**
 * Extract trigger keywords from topic string
 */
function extractTriggerKeywords(topic) {
  if (!topic) return [];

  // Common technical keywords to extract
  const patterns = [
    'auth', 'login', 'session', 'token', 'jwt', 'oauth',
    'sync', 'build', 'deploy', 'test', 'fix', 'bug',
    'api', 'endpoint', 'route', 'handler', 'middleware',
    'database', 'query', 'schema', 'migration',
    'component', 'hook', 'state', 'props', 'render'
  ];

  const topicLower = topic.toLowerCase();
  const found = patterns.filter(p => topicLower.includes(p));

  // Also extract any capitalized words (likely important)
  const caps = topic.match(/\b[A-Z][A-Za-z]+\b/g) || [];

  return [...new Set([...found, ...caps.map(c => c.toLowerCase())])].slice(0, 10);
}

/**
 * Add AESD solution to L5 precedent database
 * Closes the loop: Working solution â†’ Becomes reusable pattern
 */
function addSolutionToPrecedents(aesd_solution, topic) {
  try {
    const cliPath = path.join(__dirname, 'dba46266.js');

    const pattern = {
      trigger_context: {
        keywords: extractTriggerKeywords(topic),
        workflow: 'bug_fix',
        domain: 'esmc-production'
      },
      next_step: aesd_solution.solution || aesd_solution.solution_summary,
      evidence: {
        sessions: [aesd_solution.session_id || `Rank ${aesd_solution.rank}`],
        confidence: 0.7,
        success_rate: 0.8
      },
      user_preference_match: true,
      lesson_references: [],
      root_cause: aesd_solution.root_cause || null
    };

    execSync(`node "${cliPath}" add-pattern '${JSON.stringify(pattern).replace(/'/g, "\\'")}'`, {
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', 'pipe']
    });

    return { added: true };
  } catch (error) {
    return { added: false, error: error.message };
  }
}

// ============================================================================
// COMMAND: vet
// ============================================================================

async function executeVetting(options = {}) {
  const silent = options.silent !== false;  // Default true (silent) unless explicitly set to false

  try {
    if (!silent) console.log('ğŸ›¡ï¸ ATHENA: Initializing error detection...');

    const EpsilonATHENACoordinator = require('./86e465f5.js');
    const athena = new EpsilonATHENACoordinator();
    await athena.initialize();

    if (!silent) console.log('ğŸ›¡ï¸ ATHENA: Running PHC aggregation...');

    // Get current session context
    const workingMemoryPath = path.resolve(process.cwd(), '.claude/memory/.esmc-working-memory.json');
    let sessionContext = { topic: 'Unknown request', keywords: [] };

    if (fs.existsSync(workingMemoryPath)) {
      const workingMemory = JSON.parse(fs.readFileSync(workingMemoryPath, 'utf-8'));
      if (workingMemory.atlas_t1 && workingMemory.atlas_t1.query) {
        sessionContext.topic = workingMemory.atlas_t1.query;
        sessionContext.keywords = workingMemory.keywords_extracted || [];
      }
    }

    // Execute PHC vetting
    const vettingResult = await athena.phc.evaluateHalt(sessionContext);

    // Write result to file
    const outputPath = path.resolve(process.cwd(), '.esmc-athena-vetting-result.json');
    fs.writeFileSync(outputPath, JSON.stringify(vettingResult, null, 2));

    if (!silent) {
      console.log('ğŸ›¡ï¸ ATHENA: Vetting complete');
      console.log(`   shouldHalt: ${vettingResult.shouldHalt}`);
      console.log(`   severity: ${vettingResult.severity}`);
    }

    if (!silent) {
      console.log(JSON.stringify(vettingResult, null, 2));
    }

    return vettingResult;

  } catch (error) {
    const errorResult = {
      shouldHalt: false,
      severity: 'error',
      recommendations: [],
      component_results: {},
      error: error.message
    };

    const outputPath = path.resolve(process.cwd(), '.esmc-athena-vetting-result.json');
    fs.writeFileSync(outputPath, JSON.stringify(errorResult, null, 2));

    if (!silent) {
      console.error('âŒ ATHENA Vetting Error:', error.message);
      console.log(JSON.stringify(errorResult, null, 2));
    }

    return errorResult;
  }
}

// ============================================================================
// COMMAND: review
// ============================================================================

async function executeReview(proposalJson, options = {}) {
  const silent = options.silent !== false;  // Default true (silent) unless explicitly set to false
  const iteration = options.iteration || 1;

  try {
    const proposal = JSON.parse(proposalJson);

    if (!silent) console.log('ğŸ›¡ï¸ ATHENA: Reviewing ECHELON proposal...');

    const EpsilonATHENACoordinator = require('./86e465f5.js');
    const athena = new EpsilonATHENACoordinator();
    await athena.initialize();

    const reviewResult = {
      verdict: 'ACCEPT',
      confidence: 0,
      feedback: {
        why_rejected: [],
        what_to_change: [],
        where_to_fix: [],
        precedents_to_apply: []
      },
      iteration: iteration,
      component_results: {}
    };

    // Run error detection components
    if (!silent) console.log('ğŸ›¡ï¸ ATHENA: Checking error signatures...');
    const aesdResult = await athena.aesd.detectSimilarFailures(proposal.topic || proposal.request);
    reviewResult.component_results.aesd = aesdResult;

    if (aesdResult.similar_failures && aesdResult.similar_failures.length > 0) {
      const highSimilarity = aesdResult.similar_failures.filter(f => f.similarity >= 0.7);
      if (highSimilarity.length > 0) {
        reviewResult.verdict = 'REVISE';
        reviewResult.feedback.why_rejected.push(
          `Similar approach failed in ${highSimilarity.length} previous session(s)`
        );
        reviewResult.feedback.precedents_to_apply.push({
          rank: highSimilarity[0].session_rank,
          session_id: highSimilarity[0].session_id,
          root_cause: highSimilarity[0].root_cause,
          solution: highSimilarity[0].solution
        });
      }
    }

    // Run iteration counter
    if (!silent) console.log('ğŸ›¡ï¸ ATHENA: Checking iteration count...');
    const icResult = await athena.ic.countIterations(proposal.topic || proposal.request);
    reviewResult.component_results.ic = icResult;

    if (icResult.iterationCount > athena.ic.criticalThreshold) {
      reviewResult.verdict = 'REJECT';
      reviewResult.feedback.why_rejected.push(
        `CRITICAL: Problem attempted ${icResult.iterationCount + 1} times (max 5 exceeded)`
      );
    } else if (icResult.iterationCount > athena.ic.warningThreshold) {
      if (reviewResult.verdict === 'ACCEPT') reviewResult.verdict = 'REVISE';
      reviewResult.feedback.why_rejected.push(
        `WARNING: Attempt ${icResult.iterationCount + 1} at similar problem`
      );
    }

    // Run cross-session matcher
    if (!silent) console.log('ğŸ›¡ï¸ ATHENA: Searching for precedents...');
    const cspmResult = await athena.cspm.findPrecedents(proposal.topic || proposal.request);
    reviewResult.component_results.cspm = cspmResult;

    if (cspmResult.precedents && cspmResult.precedents.length > 0) {
      if (reviewResult.verdict === 'ACCEPT') reviewResult.verdict = 'REVISE';
      reviewResult.feedback.precedents_to_apply.push(...cspmResult.precedents.map(p => ({
        rank: p.session_rank,
        session_id: p.session_id,
        solution_summary: p.solution_summary
      })));
    }

    // Run user intervention detector
    if (!silent) console.log('ğŸ›¡ï¸ ATHENA: Checking correction patterns...');
    const uidResult = await athena.uid.detectInterventionPatterns(proposal.topic || proposal.request);
    reviewResult.component_results.uid = uidResult;

    if (uidResult.interventionCount > 3) {
      if (reviewResult.verdict === 'ACCEPT') reviewResult.verdict = 'REVISE';
      reviewResult.feedback.why_rejected.push(
        `User corrected similar patterns ${uidResult.interventionCount} times`
      );
    }

    // ============================================================================
    // ESMC 4.1: LEARNING LOOP - Error-to-Lesson + AESD-to-Precedent Pipeline
    // ============================================================================

    // FIX 1: Auto-create lesson if IC/UID thresholds exceeded
    if (icResult.iterationCount >= 3 || uidResult.interventionCount >= 3) {
      const lessonResult = createAutoLesson({
        topic: proposal.topic || proposal.request,
        ic: icResult.iterationCount,
        uid: uidResult.interventionCount,
        aesd_solutions: reviewResult.feedback.precedents_to_apply
      });

      if (lessonResult.created) {
        reviewResult.learning = reviewResult.learning || {};
        reviewResult.learning.lesson_created = lessonResult.lesson_id;
        reviewResult.learning.lesson_severity = lessonResult.lesson.severity;
        if (!silent) {
          console.log(`ğŸ§  ATHENA Learning: Auto-created ${lessonResult.lesson_id} (IC=${icResult.iterationCount}, UID=${uidResult.interventionCount})`);
        }
      }
    }

    // FIX 3: Add AESD solutions to L5 precedent database
    if (reviewResult.feedback.precedents_to_apply && reviewResult.feedback.precedents_to_apply.length > 0) {
      for (const precedent of reviewResult.feedback.precedents_to_apply) {
        if (precedent.solution || precedent.solution_summary || precedent.root_cause) {
          const addResult = addSolutionToPrecedents(precedent, proposal.topic || proposal.request);
          if (addResult.added) {
            reviewResult.learning = reviewResult.learning || {};
            reviewResult.learning.precedents_added = (reviewResult.learning.precedents_added || 0) + 1;
            if (!silent) {
              console.log(`ğŸ§  ATHENA Learning: Added solution from ${precedent.session_id || `Rank ${precedent.rank}`} to L5 precedents`);
            }
          }
        }
      }
    }

    // Calculate confidence
    let confidenceFactors = [];
    if (!aesdResult.similar_failures || aesdResult.similar_failures.length === 0) confidenceFactors.push(25);
    if (icResult.iterationCount === 0) confidenceFactors.push(25);
    if (cspmResult.precedents && cspmResult.precedents.length > 0) confidenceFactors.push(25);
    if (uidResult.interventionCount === 0) confidenceFactors.push(25);

    reviewResult.confidence = confidenceFactors.reduce((a, b) => a + b, 0);

    if (reviewResult.verdict === 'ACCEPT' && reviewResult.confidence < 60) {
      reviewResult.verdict = 'REVISE';
      reviewResult.feedback.what_to_change.push('Low confidence - recommend validation');
    }

    // Write result
    const outputPath = path.resolve(process.cwd(), '.esmc-athena-review-result.json');
    fs.writeFileSync(outputPath, JSON.stringify(reviewResult, null, 2));

    // ============================================================================
    // REDESIGN LOOP DISABLED (ESMC 3.80.0 - Prevention Architecture)
    // ============================================================================
    //
    // User directive: "Prevention better than cure"
    // Strategy: Context accuracy â†’ Pattern familiarity â†’ Zero iteration
    //
    // DISABLED LOGIC (would have been here):
    //   if (reviewResult.verdict === 'REJECT' || reviewResult.verdict === 'REVISE') {
    //     // Increment iteration counter
    //     // Send feedback to ECHELON
    //     // Trigger ECHELON redesign
    //     // Resubmit proposal to ATHENA
    //     // Loop until ACCEPT or max 5 iterations
    //   }
    //
    // CURRENT BEHAVIOR (Prevention-First):
    //   - ATHENA provides verdict + feedback
    //   - ECHELON sees feedback but does NOT automatically redesign
    //   - Focus on first-attempt accuracy via comprehensive context (mesh + REASON + domain filtering)
    //   - Iterations become RARE (exception), not ROUTINE (expected flow)
    //
    // ============================================================================

    if (!silent) {
      console.log('ğŸ›¡ï¸ ATHENA: Review complete');
      console.log(`   verdict: ${reviewResult.verdict}`);
      console.log(`   confidence: ${reviewResult.confidence}%`);
      console.log('   (Redesign loop disabled - Prevention architecture)');
      console.log(JSON.stringify(reviewResult, null, 2));
    }

    return reviewResult;

  } catch (error) {
    const errorResult = {
      verdict: 'REJECT',
      confidence: 0,
      feedback: {
        why_rejected: [`Review error: ${error.message}`],
        what_to_change: [],
        where_to_fix: [],
        precedents_to_apply: []
      },
      iteration: iteration,
      error: error.message
    };

    const outputPath = path.resolve(process.cwd(), '.esmc-athena-review-result.json');
    fs.writeFileSync(outputPath, JSON.stringify(errorResult, null, 2));

    if (!silent) {
      console.error('âŒ ATHENA Review Error:', error.message);
      console.log(JSON.stringify(errorResult, null, 2));
    }

    return errorResult;
  }
}

// ============================================================================
// CLI ARGUMENT PARSING
// ============================================================================

const args = process.argv.slice(2);
const command = args[0];

if (!command || command === '--help' || command === '-h') {
  console.log(`
ESMC 3.80.0 - Epsilon ATHENA CLI

Usage:
  node 8456819e.js vet [--silent]
  node 8456819e.js review <proposal_json> [--silent] [--iteration <num>]

Commands:
  vet              - Execute proactive error detection (PHASE 0.7)
  review           - Full proposal vetting with verdict

Options:
  --silent         - Suppress console output (JSON only)
  --iteration <N>  - Current iteration number

Examples:
  node 8456819e.js vet --silent
  node 8456819e.js review '{"topic":"Add auth"}' --iteration 2
`);
  process.exit(0);
}

// ğŸ†• ESMC 3.101.0: Silent by default for clean SDK distribution (opt-in verbose)
const verbose = process.env.ESMC_VERBOSE === 'true' || args.includes('--verbose') || args.includes('-v');

const options = {
  silent: !verbose,  // Default silent unless verbose explicitly requested
  iteration: parseInt(args[args.indexOf('--iteration') + 1]) || 1
};

(async () => {
  try {
    if (command === 'vet') {
      await executeVetting(options);
    } else if (command === 'review') {
      const proposalJson = args[1];
      if (!proposalJson) {
        console.error('âŒ Missing required argument: <proposal_json>');
        process.exit(1);
      }
      await executeReview(proposalJson, options);
    } else {
      console.error(`âŒ Unknown command: ${command}`);
      process.exit(1);
    }
  } catch (error) {
    console.error('âŒ Fatal error:', error.message);
    if (!options.silent) console.error(error.stack);
    process.exit(1);
  }
})();
